# Курс: tRPC в Next.js (после Drizzle ORM)

## Общая информация

- Формат: 4 лекции по 2 академических часа  
- Контекст: Next.js (App Router)  
- База данных: MongoDB  
- Слой доступа к данным: ранее реализован (data-access, DI, архитектурное разделение)  
- Цель курса: освоить tRPC как типобезопасный API-слой между UI и серверной логикой  

---

# Лекция 1. Минимальный tRPC API

**Цель лекции:**  
Понять RPC-модель, устройство tRPC и принцип end-to-end типобезопасности.

## План лекции

1. Проблема типобезопасности API  
   - REST и дублирование типов  
   - Контракт клиент–сервер  
   - Идея RPC  

2. Архитектурная роль tRPC  
   - Где находится в Next.js  
   - Отличие от API routes  
   - Отличие от Server Actions  

3. Базовые элементы tRPC  
   - initTRPC  
   - router  
   - procedure  
   - query  

4. Создание минимального router  
   - Одна query  
   - Возврат данных  
   - Типизация результата  

5. Инференс типов на клиенте  
   - Генерация типов автоматически  
   - Отсутствие ручного описания DTO  

6. Клиентский вызов  
   - tRPC client  
   - Первый вызов query из React  

7. Итоговая схема data-flow  
   - UI → tRPC → серверная функция  

---

# Лекция 2. CRUD через tRPC + Data-access слой

**Цель лекции:**  
Научиться строить полноценный CRUD API через tRPC и интегрировать его с существующим data-access слоем.

## План лекции

1. query и mutation  
   - Различие по семантике  
   - Соответствие CRUD-операциям  

2. Передача параметров  
   - input в procedure  
   - Типизация входных данных  

3. CRUD через tRPC  
   - Create (mutation)  
   - Read (query)  
   - Update (mutation)  
   - Delete (mutation)  

4. Интеграция с data-access слоем  
   - Вызов функций доступа к данным  
   - Сохранение архитектурного разделения  

5. Разделение роутеров по сущностям  
   - userRouter  
   - postRouter  
   - Принцип модульности  

6. Композиция роутеров  
   - merge routers  
   - Общий appRouter  

7. Архитектурная схема  
   - UI → tRPC → Access layer → БД  

---

# Лекция 3. Middleware, контекст и обработка ошибок

**Цель лекции:**  
Освоить расширяемость tRPC через middleware и context, а также корректную обработку ошибок.

## План лекции

1. Context в tRPC  
   - Что передаётся в context  
   - Связь с request  
   - DI через context  

2. Использование context для зависимостей  
   - Передача data-access  
   - Избежание глобальных импортов  

3. Middleware  
   - Назначение  
   - Порядок выполнения  
   - Примеры использования  

4. Обработка ошибок  
   - throw TRPCError  
   - Стандартизация ошибок  

5. Логирование  
   - Middleware для логирования  
   - Контроль выполнения процедур  

6. Расширяемость процедур  
   - protectedProcedure (архитектурная модель)  
   - Подготовка к авторизации  

7. Архитектурные принципы  
   - Разделение ответственности  
   - Централизация cross-cutting логики  

---

# Лекция 4. Композиция, клиентская интеграция и архитектурная целостность

**Цель лекции:**  
Сформировать целостную архитектурную модель fullstack-приложения с использованием tRPC.

## План лекции

1. Композиция роутеров  
   - Структурирование проекта  
   - Масштабирование API  

2. Интеграция с React Query  
   - useQuery  
   - useMutation  
   - Кэширование  

3. Инвалидация кэша  
   - После mutation  
   - Стратегии обновления данных  

4. Паттерны организации процедур  
   - Тонкий API-слой  
   - Логика в access-слое  

5. Анти-паттерны  
   - Бизнес-логика в router  
   - Прямые обращения к БД  
   - Дублирование типов  

6. Полный data-flow приложения  
   - UI → Hook → tRPC client  
   - Router → Access layer  
   - База данных → Ответ клиенту  

7. Итоговая архитектурная модель  
   - Границы ответственности  
   - Эволюция проекта при росте функциональности  

---

# Результат курса

После завершения курса студент:

- понимает RPC-подход и отличие от REST;  
- умеет строить типобезопасный API через tRPC;  
- интегрирует tRPC с существующим data-access слоем;  
- использует middleware и context;  
- выстраивает архитектурно корректный fullstack-поток данных в Next.js.